##内存管理：
python内存管理的方法：

1. 内存池：
用内存池来减少操作系统内存分配和回收操作，小于等于256字节对象，将直接从内存池中获取存储空间。
- 根据需要，每次从操作系统申请一块256KB，取名为arena的块内存。并按系统页大小，划分成多个pool。每个pool继续分割成n个相同的block，这是内存池最存储单位。
block的大小是8的倍数，也就是说存储13字节大小的对象，需要找block大小为16的pool获取空闲块。所有这些都头信息和链表管理起来，以便快速查找空闲区域进分配。
大于256字节的对象，直接malloc在堆上分配内存。程序运中的绝大多数对象都小于这个阈值，因此内存池策略可有效提升性能。
当所有arena的总容量超出限制(64MB)时，就不再请求新的arena内存。是如同" 对象"样，直接在堆上为对象分配内存。另外，完全空闲的arena会被释放，其内存交还给操作系统。

2. 引用传递：
对象总是按引用传递，简单点说就是通过复制指针来实现多个名字指向同一对象。因为arena也是在堆上分配的，所以无论何种类型何种大小的对象，都存储在堆上。Python没有值类型和引用类
型一说，就算是最简单的整数也是拥有标准头的完整对象。
- 如果不希望对象被修改，就需使 不可变类型，或对象复制品。
  不可变类型:int, long, str, tuple, frozenset
除了某些类型 带的 copy  法外，还可以:
使 标准库的 copy 模块进 深度复制。
序列化对象，如 pickle、cPickle、marshal。

3. 引用计数：
Python 默认采用引用计数来管理对象的内存回收。当引 计数为 0 时，将 即回收该对象内存， 要么将对应的 block 块标记为空闲，要么返还给操作系统。
- 弱引用,允许在不增加引用计数，不妨碍对象回收的情况下间接引用对象。但不是所有类型都支持弱引用，比如list、dict，弱引用会引发异常。

4. 垃圾回收：
Python拥有两套垃圾回收机制。除了引用计数，还有个专门处理循环引用的GC。通常提到垃圾回收时，都是指这个"Reference Cycle Garbage Collection"。
能引发循环引用问题的，都是那种容器类对象，如list、set、object等。对于这类对象，在为其分配内存时，会额外添加用于追踪的PyGC_Head。这些对象被添加到特殊链表里，以便GC进行管理。
- 同 .NET、JAVA一样，Python GC同样将要回收的对象分成3级代龄。GEN0管理新近加入的年轻对象，GEN1则是在上次回收后依然存活的对象，剩下GEN2存储的都生命周期极的家伙。每级代龄都有一个最大容量阈值，每次GEN0对象数量超出阈值时，都将引发垃圾回收操作。

5. 底层实现：
- dict与set 都是由散列机制hash提供的，也就意味着对dict和set中元素访问的消耗都是常数级。
























