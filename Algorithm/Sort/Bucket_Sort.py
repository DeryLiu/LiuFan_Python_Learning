'''
桶排序：

思想：
桶排序的思想近乎彻底的分治思想。

桶排序假设待排序的一组数均匀独立的分布在一个范围中，并将这一范围划分成几个子范围（桶）。
然后基于某种映射函数f ，将待排序列的关键字 k 映射到第 i 个桶中 (即桶数组B 的下标i) ，那么该关键字k 就作为 B[i]中的元素 (每个桶B[i]都是一组大小为N/M 的序列 )。

接着将各个桶中的数据有序的合并起来: 对每个桶B[i] 中的所有元素进行比较排序 (可以使用快排)。然后依次枚举输出 B[0]....B[M] 中的全部内容即是一个有序序列。

补充： 映射函数一般是 f = array[i] / k; k^2 = n; n是所有元素个数
https://segmentfault.com/image?src=http://img.blog.csdn.net/20150312112052264&objectId=1190000002595152&token=46912f7eb9fc0b2de830a20e710b0bbe

性能分析：
平均时间复杂度为线性的 O(n+C) 最优情形下，桶排序的时间复杂度为O(n)。
桶排序的空间复杂度通常是比较高的，额外开销为O(n+m)（因为要维护 M 个数组的引用）。
就是桶越多，时间效率就越高，而桶越多，空间却就越大，由此可见时间和空间是一个矛盾的两个方面。

算法稳定性:
桶排序的稳定性依赖于桶内排序。如果我们使用了快排，显然，算法是不稳定的。
http://hxraid.iteye.com/blog/647759
桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的 f(k) 值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块 (桶)。然后只需要对桶中的少量数据做先进的比较排序即可。

对 N 个关键字进行桶排序的时间复杂度分为两个部分：
(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是 O(n)。
(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(ni*logni) 。其中 ni 为第 i个桶的数据量。

很显然，第 (2) 部分是桶排序性能好坏的决定因素。这就是一个时间代价和空间代价的权衡问题了。
'''