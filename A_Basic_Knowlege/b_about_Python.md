##内存管理：
python内存管理的方法：
1.内存池：
用内存池来减少操作系统内存分配和回收操作，小于等于256字节对象，将直接从内存池中获取存储空间。
- 根据需要，每次从操作系统申请一块256KB，取名为arena的块内存。并按系统页大小，划分成多个pool。每个pool继续分割成n个相同的block，这是内存池最存储单位。
block的大小是8的倍数，也就是说存储13字节大小的对象，需要找block大小为16的pool获取空闲块。所有这些都头信息和链表管理起来，以便快速查找空闲区域进分配。
大于256字节的对象，直接malloc在堆上分配内存。程序运中的绝大多数对象都小于这个阈值，因此内存池策略可有效提升性能。
当所有arena的总容量超出限制(64MB)时，就不再请求新的arena内存。是如同" 对象"样，直接在堆上为对象分配内存。另外，完全空闲的arena会被释放，其内存交还给操作系统。

2.引用传递：
对象总是按引用传递，简单点说就是通过复制指针来实现多个名字指向同一对象。因为arena也是在堆上分配的，所以无论何种类型何种大小的对象，都存储在堆上。Python没有值类型和引用类
型一说，就算是最简单的整数也是拥有标准头的完整对象。
- 如果不希望对象被修改，就需使 不可变类型，或对象复制品。
  不可变类型:int, long, str, tuple, frozenset
除了某些类型 带的 copy  法外，还可以:
使 标准库的 copy 模块进 深度复制。
序列化对象，如 pickle、cPickle、marshal。

3.引用计数：
Python 默认采用引用计数来管理对象的内存回收。当引 计数为 0 时，将 即回收该对象内存， 要么将对应的 block 块标记为空闲，要么返还给操作系统。
- 弱引用,允许在不增加引用计数，不妨碍对象回收的情况下间接引用对象。但不是所有类型都支持弱引用，比如list、dict，弱引用会引发异常。

4.垃圾回收：
Python拥有两套垃圾回收机制。除了引用计数，还有个专门处理循环引用的GC。通常提到垃圾回收时，都是指这个"Reference Cycle Garbage Collection"。
能引发循环引用问题的，都是那种容器类对象，如list、set、object等。对于这类对象，在为其分配内存时，会额外添加用于追踪的PyGC_Head。这些对象被添加到特殊链表里，以便GC进行管理。
- 同 .NET、JAVA一样，Python GC同样将要回收的对象分成3级代龄。GEN0管理新近加入的年轻对象，GEN1则是在上次回收后依然存活的对象，剩下GEN2存储的都生命周期极的家伙。每级代龄都有一个最大容量阈值，每次GEN0对象数量超出阈值时，都将引发垃圾回收操作。

##内置类型：
- 按照用途不同，可以分为数据和程序两大类
1.数据类型:
• 空值: None
• 数字: bool, int, long, float, complex • 序列: str, unicode, list, tuple
• 字典: dict
• 集合: set, frozenset

- int:
• 从堆上按需申请名为 PyIntBlock 的缓存区域存储整数对象。
• 使用固定数组缓存 [-5, 257) 之间的 数字，只需计算下标就能获得指针。 
• PyIntBlock 内存不会返还给操作系统，直至进程结束。
因 PyIntBlock 内存只复用不回收，同时持有大量整数对象将导致内存暴涨，且不会在这些对象被回收后释放内存，造成事实上的内存泄露。

- long
当超出int限制时，会自动转换成long。作为变长对象，只要有内存足够，足以存储无法想象的天文数字。

- float
使用双精度浮点数，不能 "精确" 表示某些十进制的小数值。尤其是 "四舍五入(round)"的结果。
在内存管理上，float 也采用PyFloatBlock模式，但没有特殊的"小浮点数"。

- string
字符串是不可变类型，保存字符序列或二进制数据。
• 短字符串存储在arena区域，str、unicode单字符会被永久缓存。
• str没有缓存机制，unicode则保留1024个宽字符长度小于9的复用对象。 
• 内部包含hash值，str另有标记用来判断是否被池化。
字符串常量定义简单自由，可以是单引号、双引号或三引号。但建议用双引号表示字符串，用单引号表示字符，和其他语言习惯保持一致。

- list
从功能上看，列表类似Vector，而非数组或链表。
• 列表对象和存储元素指针的数组是分开的两块内存，后者在堆上分配。 
• 虚拟机会保留80个列表复用对象，但其元素指针数组会被释放。
• 列表会动态调整指针数组大小，预分配内存多于实际元素数量。
某些时候，可以考虑用数组代替列表。和列表存储对象指针不同，数组直接内嵌数据，既省了创建对象的内存开销，又提升了读写效率。

- tuple 
• 只读对象，元组和元素指针数组内存是一次性连续分配的。
• 虚拟机缓存n个元素数量小于20的元组复用对象。在编码中，应该尽可能用元组代替列表。除内存复用更高效外，其只读特征更利于并行开发。

- dict
采用开放地址法的哈希表实现
• 带元素容量为 8 的 smalltable，只有 "超出" 时才到堆上额外分配元素表内存。
• 虚拟机缓存 80 个字典复 对象，但在堆上分配的元素表内存会被释放。 
• 按需动态调整容量。扩容或收缩操作都将重新分配内存，重新哈希。
• 删除元素操作不会 即收缩内存。
对于字典，调用keys()、values()、items()会构造同样巨大的列表。建议用迭代器替代，以减少内存开销。iterkeys()、itervalues()、iteritems()

要判断两个字典间的差异，使用视图是最简便的做法。
```
>>> v1 = d1.viewitems()
>>> v2 = d2.viewitems()
>>>v1&v2        set([('b', 2)])
>>>v1|v2        set([('a', 1), ('b', 2), ('c', 3)])
>>>v1-v2         set([('a', 1)])
>>>v1^v2         set([('a', 1), ('c', 3)])
```

- set
集合(set)来存储 序不重复对象。所谓不重复对象，除了不是同 对象外，还包括 "值" 不能相
同。集合只能存储可哈希对象， 样有只读版本 frozenset。 判重公式:(a is b) or (hash(a) == hash(b) and eq(a, b))
在内部实现上，集合和字典 常相似，除了 Entry 没有 value 字段。集合不是序列类型，不能像 列表那样按序号访问，也不能做切 操作。
