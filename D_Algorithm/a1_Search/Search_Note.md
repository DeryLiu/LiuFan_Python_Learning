## 搜索、查找：
1.顺序查找：O(n)
2.二分查找：O(n)
3.Hash查找：O(n)

##常用Hash函数：
1. reminder method - 除留余数法：
取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即hash(k)=k mod p，p<=m。
不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突
2. folding method: 分组求和再取余数：
3. mid-square method：平方值的中间两位数取余 平方取中法：取关键字平方后的中间几位为哈希地址。
通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。
4. 直接定址法：取关键字或关键字的某个线性函数值为散列地址。即hash(k)=k 或 hash(k)=a*k+b，其中 a,b为常数（这种散列函数叫做自身函数）
5. 数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
6. 折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。

##处理冲突：
为了知道冲突产生的相同散列函数地址所对应的关键字，必须选用另外的散列函数，或者对冲突结果进行处理。
而不发生冲突的可能性是非常之小的，所以通常对冲突进行处理。常用方法有以下几种：
1. open address(开放寻址)：
线性探测(linear probing)下一个位置，缺点是容易造成聚集现象(cluster)，解决聚集现象的办法是跳跃式地查找下一个空槽。
hash_{i}=(hash(key)+d_{i}) mod m, i=1,2...k (k <=m-1) i=1,2...k,其中 hash(key)为散列函数，m为散列表长，d_{i}为增量序列，i为已发生冲突的次数。增量序列可有下列取法：
d_{i}=1,2,3...(m-1)称为 线性探测(Linear Probing)；即 d_{i}=i，或者为其他线性函数。

- 聚集（Cluster，也翻译做“堆积”）
在函数地址的表中，散列函数的结果不均匀地占据表的单元，形成区块，造成线性探测产生一次聚集（primary clustering）和平方探测的二次聚集（secondary clustering），散列到区块中的任何关键字需要查找多次试选单元才能插入表中，解决冲突，造成时间浪费。对于开放定址法，聚集会造成性能的灾难性损失，是必须避免的。

2. quadratic probing(平方探测)：
一开始的hash值为h，如果不是空槽，那就尝试h+1，还不是空槽就尝试h+4，依次继续尝试h+9，h+16等等。
3. chain：利用链表链接起来

## 查找效率：
散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。
查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：
- 散列函数是否均匀；
- 处理冲突的方法；
- 散列表的载荷因子（英语：load factor）。

载荷因子：
散列表的载荷因子定义为：∂= 填入表中的元素个数 / 散列表的长度
∂ 是散列表装满程度的标志因子。由于表长是定值，alpha 与“填入表中的元素个数”成正比，所以 ∂ 越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，∂ 越小，标明填入表中的元素越少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是载荷因子 ∂的函数，只是不同处理冲突的方法有不同的函数。
对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了荷载因子为0.75，超过此值将resize散列表。


1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 
1. 

