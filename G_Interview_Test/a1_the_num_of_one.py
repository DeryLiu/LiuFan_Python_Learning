'''
题目：
给定一个十进制正整数 N，写下从 1 开始，到 N 的所有整数， 然后数一下其中出现的所有“1”的个数。
例如:
N= 2，写下 1，2。这样只出现了 1 个“1”。
N= 12，我们会写下 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12。这样，1
的个数是 5。 问题是:
1. 写一个函数(f N)，返回1到N之间出现的“1”的个数,比如(f 12) =5。
2. 在32位整数范围内，满足条件“f(N)= N”的最大的N是多少?
'''

'''
问题一分析：
当N<10时，f(N)=1，只有1这一个数有1；

当10<N<100时，f(13)=个位出现1的个数+十位出现1的个数=2+4=6;
            f(23) = 个位出现1的个数 + 十位出现1的个数 = 3 + 10 = 13;
            f(33) = 个位出现1的个数 + 十位出现1的个数 = 4 + 10 = 14; ...
            f(93) = 个位出现1的个数 + 十位出现1的个数 = 10 + 10 = 20;
根据上面的一些尝试，下面我们推导出一般情况下，从 N 得 到 f(N)的计算方法:
1.假设 N=abcde，这里 a、b、c、d、e 分别是十进制数 N 的各 个数位上的数字。
如果要计算百位上出现1的次数，它将会受到三个因素的影响:百位上的数字，百位以下(低位)的数字，百位(更高位)以上的数字。
如果百位上的数字为 0，则可以知道，百位上可能出现1的次 数由更高位决定，
比如12013，则可以知道百位出现1的情况可能是100~199，1100~1199，2100~2199，...，11100~11199， 一共有 1 200 个。
也就是由更高位数字(12)决定，并且 --等于更高位数字(12)×当前位数(100)--。
2.如果百位上的数字为1，则可以知道，百位上可能出现1的次数不仅受更高位影响，还受低位影响，也就是由更高位和低位共同决定。
例如对于12113，受更高位影响，百位出现1的情况是100~199，1100~1199，2100~2199，...，11100~11199，一共 1200个，
和上面第一种情况一样，等于更高位数字(12)×当前位数(100)。 但是它还受低位影响，百位出现1的情况是12100~12113，一共114个，--等于低位数字(123)+1--。
3.如果百位上数字大于 1(即为 2~9)，则百位上可能出现1的次数也仅由更高位决定，
比如12213，则百位出现1的可能性 为:100~199，1100~1199，2100~2199，...，11100~11199，12100~12199，一共有1300 个，
并且--等于更高位数字+1(12+1) ×当前位数(100)--。
'''
def soulution1(n):
    iCount = 0
    iFactor = 1 # 倍数，从个位开始
    # 只要倍数不超出N的位数，则进行循环
    while int(n/iFactor) != 0:
        # 获取低位数字,当前数字为个位时为0
        iLowerNum = n - int(n / iFactor) * iFactor
        # 获取当前数字
        iCurrNum = int(n / iFactor) % 10
        # 获取高位数字
        iHigherNum = int(n / (iFactor * 10))
        # 判断当前数字是否为1
        if iCurrNum == 0:
            iCount += iHigherNum * iFactor
        elif iCurrNum == 1:
            iCount += iHigherNum * iFactor + iLowerNum + 1
        else:
            iCount += (iHigherNum + 1) * iFactor
        # 扩大一级倍数
        iFactor *=10
    return iCount
# print(soulution1(13))
# 这个方法只要分析N就可以得到 f(N)，避开了从1到N的遍历，输入长度为Len的数字N的时间复杂度为O(Len)，即为O(ln(n)/ln(10)+1)。

'''
问题二分析：
要确定最大的数N，满足f(N)=N。我们通过简单的分析可以知道:
9 以下为: 1
99 以下为: 1*10 + 10*1 = 20
999 以下为: 1*100 * 10 *20 = 300
9999 以下为: 1×1000+10×300=4000
999999999 以下为: 900000000
9999999999 以下为: 10000000000
1 个; 1×10+10×1=20 个;
1×100+10×20=300
      900000000
    10000000000
容易从上面的式子归纳出:f(10n-1)= n * 10n-1。通过这个递 推式，很容易看到，当 n = 9 时候，f(n)的开始值大于 n，所以 我们可以猜想，当 n 大于某一个数 N 时，f(n)会始终比 n 大， 也就是说，最大满足条件在 0~N 之间，亦即 N 是最大满足条件 f (n)= n 的一个上界。如果能估计出这个 N，那么只要让 n 从 N 往 0 递减，每个分别检查是否有 f(n)= n，第一个满足条件的数
写书评，赢取《编程之美--微软技术面试心得》www.ieee.org.cn/BCZM.asp 就是我们要求的整数。
因此，问题转化为如何证明上界 N 确实存在，并估计出这个 上界 N。
证明满足条件 f(n)= n 的数存在一个上界 首先，用类似数学归纳法的思路来推理这个问题。很容易得
到下面这些结论(读者朋友可以自己试着列举验证一下):
当 n 增加 10 时，f(n)至少增加 1;
当 n 增加 100 时，f(n)至少增加 20; 当 n 增加 1 000 时，f(n)至少增加 300;
当 n 增加 10 000 时，f(n)至少增加 4 000; ......
当 n 增加 10k 时，f(n)至少增加 k*10k-1。
首先，当 k>=10 时，k*10 k-1> 10 k，所以 f(n)的增加量大于 n 的增加量。
其次，f(1010-1)=1010>1010-1。如果存在 N，当 n = N 时，f(N) -N>1010-1 成立时，此时不管 n 增加多少，f(n)的值将始终大于 n。
具体来说，设 n 的增加量为 m:当 m 小于 1010-1 时，由于 f (N)-N>1010-1，因此有 f(N + m)> f(N)> N + 1010-1 > N + m， 即 f(n)的值仍然比 n 的值大;当 m 大于等于 1010-1 时，f (n)
写书评，赢取《编程之美--微软技术面试心得》www.ieee.org.cn/BCZM.asp
的增量始终比 n 的增量大，即 f(N + m)- f(N)>(N+m)- N， 也就是 f(N + m)> f(N)+ m > N + 1010-1+ m > N + m，即 f(n) 的值仍然比 n 的值大。
因此，对于满足 f(N)- N > 1010-1 成立的 N 一定是所求该数 的一个上界。
求出上界 N
又由于 f(1010-1)= n *1010-1，不妨设 N = 10K-1，有 f(10 K-1) -(10 K-1)> 1010-1，即 K*10 K-1 -(10 K-1)> 1010-1，易得 K > =11 时 候均满足。所以，当 K = 11 时，N=1011-1 即为最小一个上界。
计算这个最大数 n
令 N = 1011-1=99 999 999 999，让 n 从 N 往 0 递减，每个分别检 查是否有 f(n)= n，第一满足条件的就是我们要求的整数。很容 易解出 n = 1 111 111 110 是满足 f(n)= n 的最大整数。
扩展问题
对于其他进制表达方式，也可以试一试，看看有什么规律。 例如二进制:
f(1)= 1
f(10)= 10(因为 01, 10 有两个 1) f(11)= 100(因为 01, 10, 11 有四个 1)
'''